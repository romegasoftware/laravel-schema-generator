import { z } from 'zod';

export const UnifiedValidationRequestSchema = z.object({
    auth_type: z.enum(["password", "otp"], { message: "The selected auth type is invalid." }),
    attachments: z.array(z.object({ file: z.file().mime(['image/jpeg', 'image/png', 'application/pdf'], 'The attachments.*.file field must be a file of type: jpg, png, pdf, attachments.*.file.').max(5242880, 'The attachments.*.file field must not be greater than 5120 kilobytes.'), description: z.string().max(255, 'The attachments.*.description field must not be greater than 255 characters.').trim().nullable().optional() })).nullable().optional(),
    credentials: z.object({ email: z.email({ error: 'The credentials.email field must be a valid email address.' }).trim().min(1, 'Email is required.').max(255, 'The credentials.email field must not be greater than 255 characters.'), password: z.string().min(8, 'The credentials.password field must be at least 8 characters.').trim().nullable().optional(), otp: z.number().refine((val) => {const str = String(Math.abs(Math.floor(val))); return str.length === 6; }, { message: 'The credentials.otp field must be 6 digits.' }).nullable().optional() }).optional(),
    profile: z.object({ name: z.string({ error: 'The profile.name field is required.' }).trim().refine((val) => val != undefined && val != null && val != '', { error: 'The profile.name field is required.' }).min(1, 'The profile.name field is required.').max(150, 'The profile.name field must not be greater than 150 characters.'), bio: z.string().max(500, 'The profile.bio field must not be greater than 500 characters.').trim().nullable().optional(), website: z.preprocess((val) => (val === '' ? undefined : val), z.url({ error: 'The profile.website field must be a valid URL.' }).nullable().optional()), timezone: z.string({ error: 'The profile.timezone field is required.' }).trim().refine((val) => val != undefined && val != null && val != '', { error: 'The profile.timezone field is required.' }).min(1, 'The profile.timezone field is required.'), preferences: z.object({ accepted_terms: z.string().refine((val) => { if (val === undefined || val === null) { return false; } if (typeof val === "string") { const normalized = val.toLowerCase(); if (normalized === "yes" || normalized === "on" || normalized === "true" || normalized === "1") { return true; } } return val === true || val === 1; }, { message: 'You must accept the terms.' }).trim().optional(), tags: z.array(z.enum(["news", "updates", "offers"])).min(1, 'The profile.preferences.tags field must have at least 1 items.').max(5, 'The profile.preferences.tags field must not have more than 5 items.').refine((values) => { if (!Array.isArray(values)) { return true; } const ignoreCase = false; const strict = false; for (let i = 0; i < values.length; i++) {     for (let j = i + 1; j < values.length; j++) {         const left = values[i];         const right = values[j];         if (ignoreCase && typeof left === "string" && typeof right === "string") {             if (left.localeCompare(right, undefined, { sensitivity: "accent" }) === 0) {                 return false;             }             continue;         }         if (strict ? left === right : left == right) {             return false;         }     } } return true; }, { message: 'The profile.preferences.tags field has a duplicate value.' }).optional() }).optional(), contacts: z.array(z.object({ email: z.email({ error: 'The profile.contacts.*.email field must be a valid email address.' }).trim().min(1, 'The profile.contacts.*.email field is required.'), phone: z.string().trim().nullable().optional(), label: z.enum(["primary", "backup"], { message: "The profile.contacts.*.label field is required." }) })).min(1, 'The profile.contacts field must have at least 1 items.').optional(), address: z.object({ street: z.string({ error: 'The profile.address.street field is required.' }).trim().refine((val) => val != undefined && val != null && val != '', { error: 'The profile.address.street field is required.' }).min(1, 'The profile.address.street field is required.'), city: z.string({ error: 'The profile.address.city field is required.' }).trim().refine((val) => val != undefined && val != null && val != '', { error: 'The profile.address.city field is required.' }).min(1, 'The profile.address.city field is required.'), postal_code: z.string({ error: 'The profile.address.postal code field is required.' }).trim().refine((val) => val != undefined && val != null && val != '', { error: 'The profile.address.postal code field is required.' }).min(1, 'The profile.address.postal code field is required.').regex(/^[0-9]{5}$/, 'Postal code must be exactly 5 digits.'), country: z.string({ error: 'The profile.address.country field is required.' }).trim().refine((val) => val != undefined && val != null && val != '', { error: 'The profile.address.country field is required.' }).min(1, 'The profile.address.country field is required.').length(2, 'The profile.address.country field must be 2 characters.') }).optional() }).optional(),
    metadata: z.object({ login_count: z.number({ error: 'The metadata.login count field must be an integer.' }).min(0, 'The metadata.login count field must be at least 0.').max(1000, 'The metadata.login count field must not be greater than 1000.').optional(), last_login_at: z.string().refine((val) => { if (val === undefined || val === null) { return true; } if (typeof val !== "string") { return false; } const timestamp = Date.parse(val); return !Number.isNaN(timestamp); }, { message: 'The metadata.last login at field must be a valid date.' }).trim().nullable().optional(), status: z.enum(["pending", "approved", "rejected"], { message: "The metadata.status field is required." }) }).optional(),
});
export type UnifiedValidationRequestSchemaType = z.infer<typeof UnifiedValidationRequestSchema>;

export const UnifiedDataSchema = z.object({
    account_details: z.object({ name: z.string({ error: 'The account details.name field is required.' }).trim().refine((val) => val != undefined && val != null && val != '', { error: 'The account details.name field is required.' }).min(1, 'The account details.name field is required.').max(120, 'The account details.name field must not be greater than 120 characters.'), email: z.string().max(255, 'The account details.email field must not be greater than 255 characters.').trim().nullable().optional(), timezone: z.string().max(50, 'The account details.timezone field must not be greater than 50 characters.').trim().nullable().optional(), status: z.enum(["pending", "active", "inactive", "deleted"], { message: "The account details.status field is required." }), priority: z.number({ error: 'The account details.priority field must be an integer.' }).refine((val) => val != undefined && val != null, { error: 'The account details.priority field is required.' }).min(1, 'The account details.priority field must be at least 1.').max(10, 'The account details.priority field must not be greater than 10.'), address: z.object({ street: z.string({ error: 'The account details.address.street field is required.' }).trim().refine((val) => val != undefined && val != null && val != '', { error: 'The account details.address.street field is required.' }).min(1, 'The account details.address.street field is required.').max(120, 'The account details.address.street field must not be greater than 120 characters.'), city: z.string({ error: 'The account details.address.city field is required.' }).trim().refine((val) => val != undefined && val != null && val != '', { error: 'The account details.address.city field is required.' }).min(1, 'The account details.address.city field is required.').max(80, 'The account details.address.city field must not be greater than 80 characters.'), state: z.string({ error: 'The account details.address.state field is required.' }).trim().refine((val) => val != undefined && val != null && val != '', { error: 'The account details.address.state field is required.' }).min(1, 'The account details.address.state field is required.').max(2, 'The account details.address.state field must not be greater than 2 characters.'), postal_code: z.string({ error: 'The account details.address.postal code field is required.' }).trim().refine((val) => val != undefined && val != null && val != '', { error: 'The account details.address.postal code field is required.' }).min(1, 'The account details.address.postal code field is required.').regex(/^[0-9]{5}$/, 'The account details.address.postal code field format is invalid.'), country: z.string({ error: 'The account details.address.country field is required.' }).trim().refine((val) => val != undefined && val != null && val != '', { error: 'The account details.address.country field is required.' }).min(1, 'The account details.address.country field is required.').length(2, 'The account details.address.country field must be 2 characters.') }), preferences: z.object({ marketing_opt_in: z.preprocess((val) => { if (typeof val === "string") { const normalized = val.toLowerCase(); if (normalized === "true" || normalized === "1" || normalized === "on" || normalized === "yes") { return true; } if (normalized === "false" || normalized === "0" || normalized === "off" || normalized === "no") { return false; } } if (val === 1) { return true; } if (val === 0) { return false; } return val; }, z.boolean().optional()), contacts: z.array(z.object({ label: z.enum(["primary", "backup"], { message: "The account details.preferences.contacts.*.label field is required." }), email: z.email({ error: 'The account details.preferences.contacts.*.email field must be a valid email address.' }).trim().min(1, 'The account details.preferences.contacts.*.email field is required.'), phone: z.string().max(20, 'The account details.preferences.contacts.*.phone field must not be greater than 20 characters.').trim().nullable().optional() })).nullable() }).nullable().optional() }),
    projects: z.array(z.object({ title: z.string({ error: 'The projects.*.title field is required.' }).trim().refine((val) => val != undefined && val != null && val != '', { error: 'The projects.*.title field is required.' }).min(1, 'The projects.*.title field is required.').max(150, 'The projects.*.title field must not be greater than 150 characters.'), summary: z.string().max(500, 'The projects.*.summary field must not be greater than 500 characters.').trim().nullable().optional(), status_state: z.enum(["pending", "active", "inactive", "deleted"], { message: "The projects.*.status state field is required." }), metrics: z.array(z.object({ key: z.string({ error: 'The projects.*.metrics.*.key field is required.' }).trim().refine((val) => val != undefined && val != null && val != '', { error: 'The projects.*.metrics.*.key field is required.' }).min(1, 'The projects.*.metrics.*.key field is required.'), value: z.number({ error: 'The projects.*.metrics.*.value field is required.' }).refine((val) => val != undefined && val != null, { error: 'The projects.*.metrics.*.value field is required.' }).min(0, 'The projects.*.metrics.*.value field must be at least 0.'), trend: z.enum(["up", "down", "flat"]).nullable().optional() })).min(1, 'The projects.*.metrics field must have at least 1 items.'), schedule: z.object({ starts_at: z.string({ error: 'The projects.*.schedule.*.starts at field is required.' }).trim().refine((val) => val != undefined && val != null && val != '', { error: 'The projects.*.schedule.*.starts at field is required.' }).min(1, 'The projects.*.schedule.*.starts at field is required.').refine((val) => { if (val === undefined || val === null) { return true; } if (typeof val !== "string") { return false; } const timestamp = Date.parse(val); return !Number.isNaN(timestamp); }, { message: 'The projects.*.schedule.*.starts at field must be a valid date.' }), ends_at: z.string().refine((val) => { if (val === undefined || val === null) { return true; } if (typeof val !== "string") { return false; } const timestamp = Date.parse(val); return !Number.isNaN(timestamp); }, { message: 'The projects.*.schedule.*.ends at field must be a valid date.' }).trim().nullable().optional() }).optional() })).min(1, 'The projects field must have at least 1 items.'),
    notes: z.string().max(500, 'The notes field must not be greater than 500 characters.').trim().nullable().optional(),
});
export type UnifiedDataSchemaType = z.infer<typeof UnifiedDataSchema>;

